{"entries":[{"timestamp":1751617756437,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_forever\" x=\"0\" y=\"0\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":62}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":306,"start2":306,"length1":52,"length2":8},{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1751617756436,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":"","main.py":"\n","custom.ts":"\n/**\n* Blocs personnalisés pour MaqueenPlusV2 by Planète Sciences Occitanie\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n\n//% weight=100 color=#0fbc11 icon=\"\"\n//% groups=['Instructions générales', 'Déplacement du robot', 'Détection de l'environnement', 'LEDs', 'Caméra IA']\nnamespace Planete {\n\n    //Motor selection enumeration\n    export enum MyEnumMotor {\n        //% block=\"à droite\"\n        LeftMotor,\n        //% block=\"à gauche\"\n        RightMotor,\n    };\n\n    //Motor direction enumeration selection\n    export enum MyEnumDir {\n        //% block=\"en avant\"\n        Forward,\n        //% block=\"en arrière\"\n        Backward\n    };\n\n    //Symbol selection\n    export enum MySymbol {\n        //%block=\"=\"\n        Egal,\n        //%block=\">\"\n        Superieur,\n        //%block=\"<\"\n        Inferieur,\n    }\n\n    //Line sensor selection\n    export enum MyEnumLineSensor {\n        //% block=\"L2\"\n        SensorL2,\n        //% block=\"L1\"\n        SensorL1,\n        //% block=\"M\"\n        SensorM,\n        //% block=\"R1\"\n        SensorR1,\n        //% block=\"R2\"\n        SensorR2,\n    };\n\n    //Detection selection\n    export enum MyEnumDetection {\n        //% block=\"détecte\"\n        Detect,\n        //% block=\"ne détecte pas\"\n        NotDetect,\n    };\n\n    //LED light selection enumeration\n    export enum MyEnumLed {\n        //% block=\"le feu rouge gauche\"\n        LeftLed,\n        //% block=\"le feu rouge droit\"\n        RightLed,\n        //% block=\"tous les feux rouges\"\n        AllLed,\n    };\n\n    //LED light switch enumeration selection\n    export enum MyEnumSwitch {\n        //% block=\"Éteindre\"\n        Close,\n        //% block=\"Allumer\"\n        Open,\n    };\n\n    /**\n * Well known colors for a NeoPixel strip\n */\n    export enum NeoPixelColors {\n        //% block=rouge\n        Red = 0xFF0000,\n        //% block=orange\n        Orange = 0xFFA500,\n        //% block=jaune\n        Yellow = 0xFFFF00,\n        //% block=vert\n        Green = 0x00FF00,\n        //% block=bleu\n        Blue = 0x0000FF,\n        //% block=indigo\n        Indigo = 0x4b0082,\n        //% block=violet\n        Violet = 0x8a2be2,\n        //% block=rose\n        Purple = 0xFF00FF,\n        //% block=blanc\n        White = 0xFFFFFF,\n        //% block=noir\n        Black = 0x000000\n    };\n\n    export enum CarLightColors {\n        //% block=rouge\n        Red = 1,\n        //% block=vert\n        Green = 2,\n        //% block=jaune\n        Yellow = 3,\n        //% block=bleu\n        Blue = 4,\n        //% block=rose\n        Purple = 5,\n        //% block=cyan\n        Cyan = 6,\n        //% block=blanc\n        White = 7,\n        //% block=noir\n        Black = 0\n    };\n\n\n\n    //% block\n\n    function mydelayUs(unit: number): void {\n        let i\n        while ((--unit) > 0) {\n            for (i = 0; i < 1; i++) {\n            }\n        }\n    }\n\n    const I2CADDR = 0x10;\n    const ADC0_REGISTER = 0X1E;\n    const ADC1_REGISTER = 0X20;\n    const ADC2_REGISTER = 0X22;\n    const ADC3_REGISTER = 0X24;\n    const ADC4_REGISTER = 0X26;\n    const LEFT_LED_REGISTER = 0X0B;\n    const RIGHT_LED_REGISTER = 0X0C;\n    const LEFT_MOTOR_REGISTER = 0X00;\n    const RIGHT_MOTOR_REGISTER = 0X02;\n    const LINE_STATE_REGISTER = 0X1D;\n    const VERSION_CNT_REGISTER = 0X32;\n    const VERSION_DATA_REGISTER = 0X33;\n\n    /**\n     *  Initialisation contantes pour les LEDs\n     */\n\n    let neopixel_buf = pins.createBuffer(16 * 3);\n    for (let i = 0; i < 16 * 3; i++) {\n        neopixel_buf[i] = 0\n    }\n    let _brightness = 255\n\n\n\n    /**\n     *  Initialiser le Maqueen \n     */\n\n    //% weight=100\n    //%block=\"Initialiser le Maqueen\" group=\"Instructions générales\"\n    export function I2CInit(): void {\n        let Version_v = 0;\n        //V3 systemReset\n        let allBuffer = pins.createBuffer(2);\n        allBuffer[0] = 0x49;\n        allBuffer[1] = 1;\n        pins.i2cWriteBuffer(I2CADDR, allBuffer);\n        basic.pause(100);//waiting  reset\n\n        pins.i2cWriteNumber(I2CADDR, 0x32, NumberFormat.Int8LE);\n        Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);\n        while (Version_v == 0) {\n            basic.showLeds(`\n                # . . . #\n                . # . # .\n                . . # . .\n                . # . # .\n                # . . . #\n                `, 10)\n            basic.pause(500)\n            basic.clearScreen()\n            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);\n            Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);\n        }\n        basic.showLeds(`\n                . . . . .\n                . . . . #\n                . . . # .\n                # . # . .\n                . # . . .\n                `, 10)\n        basic.pause(500)\n        basic.clearScreen()\n    }\n\n\n    /**\n * Déplacement robot avant/arrière \n * @param edir   Motor direction selection enumeration\n */\n\n    //% block=\"Se déplacer %edir à la vitesse %speed\" group=\"Déplacement du robot\"\n    //% weight=99\n    export function controlMotorAvant(edir: MyEnumDir, speed: number): void {\n        let allBuffer = pins.createBuffer(5);\n        allBuffer[0] = LEFT_MOTOR_REGISTER;\n        allBuffer[1] = edir;\n        allBuffer[2] = speed;\n        allBuffer[3] = edir;\n        allBuffer[4] = speed;\n        pins.i2cWriteBuffer(I2CADDR, allBuffer)\n    }\n\n    /**\n     * Utiliser le détecteur Ultrasons\n     */\n\n    //% block=\"la distance en cm mesurée par le détecteur utrasons %symbol %valeur\" group=\"Détection de l'environnement\"\n    //% weight=94\n\n    export function readUltrasonic(symbol: MySymbol, valeur: number): boolean {\n        let data, trig, echo, x;\n        trig = DigitalPin.P13;\n        echo = DigitalPin.P14;\n        x = valeur;\n        pins.digitalWritePin(trig, 1);\n        mydelayUs(10);\n        pins.digitalWritePin(trig, 0)\n        data = pins.pulseIn(echo, PulseValue.High, 1000 * 58);\n        if (data == 0) //repeat\n        {\n            pins.digitalWritePin(trig, 1);\n            mydelayUs(10);\n            pins.digitalWritePin(trig, 0);\n            data = pins.pulseIn(echo, PulseValue.High, 1000 * 58)\n        }\n        //59.259 / ((331.5 + 0.6 * (float)(10)) * 100 / 1000000.0) // The ultrasonic velocity (cm/us) compensated by temperature\n        data = data / 59.259;\n\n        if (data <= 0)\n            data = 0;\n        if (data > 300)\n            data = 300;\n        data = Math.round(data);\n\n        switch (symbol) {\n            case MySymbol.Egal:\n                return data == x;\n                break;\n            case MySymbol.Superieur:\n                return data > x;\n                break;\n            case MySymbol.Inferieur:\n                return data < x;\n                break;\n        }\n    }\n\n\n\n    /**\n     * Stopper tous les moteurs\n     */\n\n    //% block=\"STOP Robot\" group=\"Déplacement du robot\"\n    //% weight=98\n    export function controlMotorStop(): void {\n        let allBuffer = pins.createBuffer(5);\n        allBuffer[0] = LEFT_MOTOR_REGISTER;\n        allBuffer[1] = 0;\n        allBuffer[2] = 0;\n        allBuffer[3] = 0;\n        allBuffer[4] = 0;\n        pins.i2cWriteBuffer(I2CADDR, allBuffer)\n    }\n\n\n    /**\n     * Faire tourner robot\n     * @param emotor Motor selection enumeration\n     */\n\n    //% block=\"Tourner %emotor à la vitesse %speed\" group=\"Déplacement du robot\"\n    //% weight=99\n    export function TourneMotor(emotor: MyEnumMotor, speed: number): void {\n        let edir = MyEnumDir.Forward;\n        switch (emotor) {\n\n            case MyEnumMotor.LeftMotor:\n                let allBuffer = pins.createBuffer(5);\n                allBuffer[0] = LEFT_MOTOR_REGISTER;\n                allBuffer[1] = edir;\n                allBuffer[2] = speed;\n                allBuffer[3] = edir;\n                allBuffer[4] = 0;\n                pins.i2cWriteBuffer(I2CADDR, allBuffer)\n                break;\n            case MyEnumMotor.RightMotor:\n                let allBuffer1 = pins.createBuffer(3);\n                allBuffer1[0] = LEFT_MOTOR_REGISTER;\n                allBuffer1[1] = edir;\n                allBuffer1[2] = 0;\n                allBuffer1[3] = edir;\n                allBuffer1[4] = speed;\n                pins.i2cWriteBuffer(I2CADDR, allBuffer1);\n                break;\n        }\n    }\n\n\n    /**\n        * Durée d'action\n        * @param duree durée pendant laquelle l'action précédente va être exécutée\n        */\n\n    //% block=\"pendant %duree millisecondes\" group=\"Instructions générales\"\n    //% weight=99\n     export function pause(duree: number): void {\n        basic.pause(duree);\n    }\n\n    /**\n     * Détection ou non de la ligne par le capteur de suivi\n     * @param eline Select the inspection sensor enumeration\n     */\n\n    //% block=\"le capteur %eline %detection la ligne\" group=\"Détection de l'environnement\"\n    //% weight=96\n    export function detectionLineSensorState(eline: MyEnumLineSensor, detection: MyEnumDetection): boolean {\n        pins.i2cWriteNumber(I2CADDR, LINE_STATE_REGISTER, NumberFormat.Int8LE);\n        let data = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE)\n        let statesensor;\n        let stateuser;\n        switch (eline) {\n            case MyEnumLineSensor.SensorL1:\n                statesensor = (data & 0x08) == 0x08 ? 1 : 0;\n                break;\n            case MyEnumLineSensor.SensorM:\n                statesensor = (data & 0x04) == 0x04 ? 1 : 0;\n                break;\n            case MyEnumLineSensor.SensorR1:\n                statesensor = (data & 0x02) == 0x02 ? 1 : 0;\n                break;\n            case MyEnumLineSensor.SensorL2:\n                statesensor = (data & 0x10) == 0X10 ? 1 : 0;\n                break;\n            default:\n                statesensor = (data & 0x01) == 0x01 ? 1 : 0;\n                break;\n        }\n        switch (detection) {\n            case MyEnumDetection.Detect:\n                stateuser = 1;\n                break;\n            case MyEnumDetection.NotDetect:\n                stateuser = 0;\n                break;\n        }\n        return statesensor == stateuser;\n    }\n\n    /**\n     * Contrôle les LEDs rouges gauche et droit\n     * @param eled LED lamp selection\n     * @param eSwitch Control LED light on or off\n     */\n\n    //% block=\"%eSwitch %eled\" group=\"LEDs\"\n    //% weight=97\n    export function controlLED(eSwitch: MyEnumSwitch, eled: MyEnumLed): void {\n        switch (eled) {\n            case MyEnumLed.LeftLed:\n                let leftLedControlBuffer = pins.createBuffer(2);\n                leftLedControlBuffer[0] = LEFT_LED_REGISTER;\n                leftLedControlBuffer[1] = eSwitch;\n                pins.i2cWriteBuffer(I2CADDR, leftLedControlBuffer);\n                break;\n            case MyEnumLed.RightLed:\n                let rightLedControlBuffer = pins.createBuffer(2);\n                rightLedControlBuffer[0] = RIGHT_LED_REGISTER;\n                rightLedControlBuffer[1] = eSwitch;\n                pins.i2cWriteBuffer(I2CADDR, rightLedControlBuffer);\n                break;\n            default:\n                let allLedControlBuffer = pins.createBuffer(3);\n                allLedControlBuffer[0] = LEFT_LED_REGISTER;\n                allLedControlBuffer[1] = eSwitch;\n                allLedControlBuffer[2] = eSwitch;\n                pins.i2cWriteBuffer(I2CADDR, allLedControlBuffer);\n                break;\n        }\n    }\n\n    /**\n     * Set the brightness of RGB LED\n     * @param brightness  , eg: 100\n     */\n\n    //% weight=70\n    //% brightness.min=0 brightness.max=255\n    //% block=\"Fixer la luminosité des LEDs à |%brightness\" group=\"LEDs\"\n    export function setBrightness(brightness: number) {\n        _brightness = brightness;\n    }\n\n    /**\n     * Choisir la couleur des LEDs\n     * @param rgb couleur\n     */\n\n    //% weight=60\n    //% block=\"Allumer les LEDs en |%rgb=neopixel_colors\" group=\"LEDs\"\n    export function showColor(rgb: number) {\n        let pin = DigitalPin.P15;\n        let r = (rgb >> 16) * (_brightness / 255);\n        let g = ((rgb >> 8) & 0xFF) * (_brightness / 255);\n        let b = ((rgb) & 0xFF) * (_brightness / 255);\n        for (let i = 0; i < 16 * 3; i++) {\n            if ((i % 3) == 0)\n                neopixel_buf[i] = Math.round(g)\n            if ((i % 3) == 1)\n                neopixel_buf[i] = Math.round(r)\n            if ((i % 3) == 2)\n                neopixel_buf[i] = Math.round(b)\n        }\n        ws2812b.sendBuffer(neopixel_buf, pin)\n    }\n\n    /**\n     * Choisir la couleur pour une LED spécifique\n     * @param index  , eg: DigitalPin.P15\n     */\n\n    //% weight=60\n    //% index.min=0 index.max=3\n    //% pin.defl=DigitalPin.P15\n    //% block=\"Allumer la LED numéro |%index en |%rgb=neopixel_colors\" group=\"LEDs\"\n    export function setIndexColor(index: number, rgb: number) {\n        let pin = DigitalPin.P15;\n        let f = index;\n        let t = index;\n        let r = (rgb >> 16) * (_brightness / 255);\n        let g = ((rgb >> 8) & 0xFF) * (_brightness / 255);\n        let b = ((rgb) & 0xFF) * (_brightness / 255);\n\n        if (index > 15) {\n            if (((index >> 8) & 0xFF) == 0x02) {\n                f = index >> 16;\n                t = index & 0xff;\n            } else {\n                f = 0;\n                t = -1;\n            }\n        }\n        for (let i = f; i <= t; i++) {\n            neopixel_buf[i * 3 + 0] = Math.round(g)\n            neopixel_buf[i * 3 + 1] = Math.round(r)\n            neopixel_buf[i * 3 + 2] = Math.round(b)\n        }\n        ws2812b.sendBuffer(neopixel_buf, pin)\n\n    }\n\n    /**\n        * Turn off all RGB LEDs\n        * eg: DigitalPin.P15\n        */\n\n    //% weight=40\n    //% block=\"Éteindre les 4 LEDS\" group=\"LEDs\"\n    export function ledBlank() {\n        let pin = DigitalPin.P15;\n        showColor(0)\n    }\n\n}\n\n\n\nenum Content1 {\n    //% block=\"X centre\"\n    xCenter = 1,\n    //% block=\"Y centre\"\n    yCenter = 2,\n    //% block=\"largeur\"\n    width = 3,\n    //% block=\"hauteur\"\n    height = 4\n};\n\nenum Content2 {\n    //% block=\"X début\"\n    xOrigin = 1,\n    //% block=\"Y début\"\n    yOrigin = 2,\n    //% block=\"X fin\"\n    xTarget = 3,\n    //% block=\"Y fin\"\n    yTarget = 4\n};\n\nenum Content3 {\n    //% block=\"ID\"\n    ID = 5,\n    //% block=\"X centre\"\n    xCenter = 1,\n    //% block=\"Y centre\"\n    yCenter = 2,\n    //% block=\"largeur\"\n    width = 3,\n    //% block=\"hauteur\"\n    height = 4\n};\n\nenum Content4 {\n    //% block=\"ID\"\n    ID = 5,\n    //% block=\"X début\"\n    xOrigin = 1,\n    //% block=\"Y début\"\n    yOrigin = 2,\n    //% block=\"X fin\"\n    xTarget = 3,\n    //% block=\"Y fin\"\n    yTarget = 4\n};\n\nenum HUSKYLENSResultType_t {\n    //%block=\"Le cadre\"\n    HUSKYLENSResultBlock = 1,\n    //%block=\"La flèche\"\n    HUSKYLENSResultArrow = 2,\n};\n\nenum HUSKYLENSResultType_t_2 {\n    //%block=\"cadres\"\n    HUSKYLENSResultBlock = 1,\n    //%block=\"flèches\"\n    HUSKYLENSResultArrow = 2,\n};\n\nlet FIRST = {\n    first: -1,\n    xCenter: -1,\n    xOrigin: -1,\n    protocolSize: -1,\n    algorithmType: -1,\n    requestID: -1,\n};\n\nenum protocolCommand {\n    COMMAND_REQUEST = 0x20,\n    COMMAND_REQUEST_BLOCKS = 0x21,\n    COMMAND_REQUEST_ARROWS = 0x22,\n    COMMAND_REQUEST_LEARNED = 0x23,\n    COMMAND_REQUEST_BLOCKS_LEARNED = 0x24,\n    COMMAND_REQUEST_ARROWS_LEARNED = 0x25,\n    COMMAND_REQUEST_BY_ID = 0x26,\n    COMMAND_REQUEST_BLOCKS_BY_ID = 0x27,\n    COMMAND_REQUEST_ARROWS_BY_ID = 0x28,\n    COMMAND_RETURN_INFO = 0x29,\n    COMMAND_RETURN_BLOCK = 0x2A,\n    COMMAND_RETURN_ARROW = 0x2B,\n    COMMAND_REQUEST_KNOCK = 0x2C,\n    COMMAND_REQUEST_ALGORITHM = 0x2D,\n    COMMAND_RETURN_OK = 0x2E,\n    COMMAND_REQUEST_LEARN = 0x2F,\n    COMMAND_REQUEST_FORGET = 0x30,\n    COMMAND_REQUEST_SENSOR = 0x31,\n\n};\n\nenum protocolAlgorithm {\n    //%block=\"Reconnaissance faciale\"\n    ALGORITHM_FACE_RECOGNITION = 0,\n    //%block=\"Suivi d'objet\"\n    ALGORITHM_OBJECT_TRACKING = 1,\n    //%block=\"Reconnaissance d'object\"\n    ALGORITHM_OBJECT_RECOGNITION = 2,\n    //%block=\"Suivi de ligne\"\n    ALGORITHM_LINE_TRACKING = 3,\n    //%block=\"Reconnaissance de couleur\"\n    ALGORITHM_COLOR_RECOGNITION = 4,\n    //%block=\"Reconnaissance d'étiquettes\"\n    ALGORITHM_TAG_RECOGNITION = 5,\n    //%block=\"Classification d'objet\"\n    OBJECTCLASSIFICATION,\n    //%block=\"Reconnaissance de QR code\"\n    QRRECOGMITION,\n    //%block=\"Reconnaissance de code-barres\"\n    BARCODERECOGNITION,\n\n};\n\n//% weight=100  color=#e7660b icon=\"\\uf083\" \n//% groups=['Instructions générales', 'Autres', 'Affichage sur l'écran', 'Nombre', 'Conditions']\nnamespace Planete_camera_IA {\n\n    let protocolPtr: number[][] = [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]\n    let Protocol_t: number[] = [0, 0, 0, 0, 0, 0]\n    let i = 1;\n    let FRAME_BUFFER_SIZE = 128\n    let HEADER_0_INDEX = 0\n    let HEADER_1_INDEX = 1\n    let ADDRESS_INDEX = 2\n    let CONTENT_SIZE_INDEX = 3\n    let COMMAND_INDEX = 4\n    let CONTENT_INDEX = 5\n    let PROTOCOL_SIZE = 6\n    let send_index = 0;\n    let receive_index = 0;\n\n    let COMMAND_REQUEST = 0x20;\n\n    let receive_buffer: number[] = [];\n    let send_buffer: number[] = [];\n    let buffer: number[] = [];\n\n    let send_fail = false;\n    let receive_fail = false;\n    let content_current = 0;\n    let content_end = 0;\n    let content_read_end = false;\n\n    let command: number\n    let content: number\n\n\n    //% advanced=true shim=i2c::init\n    function init(): void {\n        return;\n    }\n\n    /**\n     * HuskyLens init I2C until success\n     */\n    //%block=\"Initialisation de la caméra\" group=\"Instructions générales\"\n    //% weight=90\n    export function initI2c(): void {\n        init();\n        while (!readKnock());\n    }\n\n    /**\n     * HuskyLens change mode algorithm until success.\n     */\n    //%block=\"Placer la caméra en mode %mode\" group=\"Instructions générales\"\n    //% weight=85\n    export function initMode(mode: protocolAlgorithm) {\n        writeAlgorithm(mode, protocolCommand.COMMAND_REQUEST_ALGORITHM)\n        while (!wait(protocolCommand.COMMAND_RETURN_OK));\n    }\n    /**\n     * HuskyLens requests data and stores it in the result.\n     */\n\n    //% block=\"Enregistrer les données de la  caméra\" group=\"Instructions générales\"\n    //% weight=80\n    export function request(): void {\n        protocolWriteCommand(protocolCommand.COMMAND_REQUEST)\n        processReturn();\n    }\n\n    /**\n      * Huskylens forget all learning data of the current algorithm\n      */\n    //%block=\"Oublier toutes les données apprises\" group=\"Instructions générales\"\n    //% weight=75\n    export function forgetLearn(): void {\n        writeAlgorithm(0x47, 0X37)\n        //while(!wait(protocolCommand.COMMAND_RETURN_OK));\n    }\n\n    /**\n    * The box or arrow HuskyLens got from result appears in screen?\n    */\n    //%block=\"%Ht apparaît à l'écran\" group=\"Conditions\"\n    //% weight=70\n    export function isAppear_s(Ht: HUSKYLENSResultType_t): boolean {\n        switch (Ht) {\n            case 1:\n                return countBlocks_s() != 0 ? true : false;\n            case 2:\n                return countArrows_s() != 0 ? true : false;\n            default:\n                return false;\n        }\n    }\n\n    /**\n    * The ID Huskylens got from result has been learned before?\n    * @param id to id ,eg: 1\n    */\n    //% block=\"L'ID %id est apprise par la caméra\" group=\"Conditions\"\n    //% weight=68\n    export function isLearned(id: number): boolean {\n        let hk_x = countLearnedIDs();\n        if (id <= hk_x) return true;\n        return false;\n    }\n    /**\n    * The box or arrow corresponding to ID obtained by HuskyLens from result appears in screen？\n    * @param id to id ,eg: 1\n    */\n    //% block=\"%Ht correspondant à l'ID %id apparaît à l'écran\" group=\"Conditions\"\n    //% weight=65\n    export function isAppear(Ht: HUSKYLENSResultType_t, id: number): boolean {\n        switch (Ht) {\n            case 1:\n                return countBlocks(id) != 0 ? true : false;\n            case 2:\n                return countArrows(id) != 0 ? true : false;\n            default:\n                return false;\n        }\n    }\n\n    /**\n    * HuskyLens get the parameter of the box corresponding to ID from result.\n    * @param id to id ,eg: 1\n    */\n    //%block=\"$number1 du cadre de l'ID $id\" group=\"Autres\"\n    //% weight=60\n    export function readeBox(id: number, number1: Content1): number {\n        let hk_y = cycle_block(id, 1);\n        let hk_x\n        if (countBlocks(id) != 0) {\n            if (hk_y != null) {\n                switch (number1) {\n                    case 1:\n                        hk_x = protocolPtr[hk_y][1]; break;\n                    case 2:\n                        hk_x = protocolPtr[hk_y][2]; break;\n                    case 3:\n                        hk_x = protocolPtr[hk_y][3]; break;\n                    case 4:\n                        hk_x = protocolPtr[hk_y][4]; break;\n                }\n            }\n            else hk_x = -1;\n        }\n        else hk_x = -1;\n        return hk_x;\n    }\n    /**\n    * HuskyLens get the parameter of the arrow corresponding to ID from result.\n    * @param id to id ,eg: 1\n    */\n\n    //%block=\"$number1 de la flèche de l'ID $id\" group=\"Autres\"\n    //% weight=55\n    export function readeArrow(id: number, number1: Content2): number {\n        let hk_y = cycle_arrow(id, 1);\n        let hk_x\n        if (countArrows(id) != 0) {\n            if (hk_y != null) {\n\n                switch (number1) {\n                    case 1:\n                        hk_x = protocolPtr[hk_y][1]; break;\n                    case 2:\n                        hk_x = protocolPtr[hk_y][2]; break;\n                    case 3:\n                        hk_x = protocolPtr[hk_y][3]; break;\n                    case 4:\n                        hk_x = protocolPtr[hk_y][4]; break;\n                    default:\n                        hk_x = -1;\n                }\n            }\n            else hk_x = -1;\n        }\n        else hk_x = -1;\n        return hk_x;\n    }\n\n    /**\n    * HuskyLens get the number of the learned ID from result.\n    */\n    //%block=\"Nombre total d'IDs appris\" group=\"Nombre\"\n    //% weight=50\n    export function getIds(): number {\n        return Protocol_t[2];\n    }\n\n    /**\n    * HuskyLens get the box or arrow total number from result.\n    * \n    */\n    //%block=\"Nombre total de %Ht\" group=\"Nombre\"\n    //% weight=47\n    export function getBox(Ht: HUSKYLENSResultType_t_2): number {\n        switch (Ht) {\n            case 1:\n                return countBlocks_s();\n            case 2:\n                return countArrows_s();\n            default:\n                return 0;\n        }\n    }\n\n\n    /**\n    * Set ID name\n    * @param id to id ,eg: 1\n    * @param name to name ,eg: \"DFRobot\"\n    */\n    //%block=\"Nommer l'ID %id : %name\" group=\"Affichage sur l'écran\"\n    //% weight=28\n    export function writeName(id: number, name: string): void {\n        //do{\n        let newname = name;\n        let buffer = husky_lens_protocol_write_begin(0x2f);\n        send_buffer[send_index] = id;\n        send_buffer[send_index + 1] = (newname.length + 1) * 2;\n        send_index += 2;\n        for (let i = 0; i < newname.length; i++) {\n            send_buffer[send_index] = newname.charCodeAt(i);\n            //serial.writeNumber(newname.charCodeAt(i))\n            send_index++;\n        }\n        send_buffer[send_index] = 0;\n        send_index += 1;\n        let length = husky_lens_protocol_write_end();\n        let Buffer = pins.createBufferFromArray(buffer);\n        protocolWrite(Buffer);\n        //}while(!wait(protocolCommand.COMMAND_RETURN_OK));\n    }\n    /**\n    * Display characters on the screen\n    * @param name to name ,eg: \"DFRobot\"\n    * @param x to x ,eg: 150\n    * @param y to y ,eg: 30\n    */\n    //%block=\"Afficher %name à la position x %x y %y sur l'écran\" group=\"Affichage sur l'écran\"\n    //% weight=27\n    //% x.min=0 x.max=319\n    //% y.min=0 y.max=210\n    export function writeOSD(name: string, x: number, y: number): void {\n        //do{\n        let buffer = husky_lens_protocol_write_begin(0x34);\n        send_buffer[send_index] = name.length;\n        if (x > 255) {\n            send_buffer[send_index + 2] = (x % 255);\n            send_buffer[send_index + 1] = 0xff;\n        } else {\n            send_buffer[send_index + 1] = 0;\n            send_buffer[send_index + 2] = x;\n        }\n        send_buffer[send_index + 3] = y;\n        send_index += 4;\n        for (let i = 0; i < name.length; i++) {\n            send_buffer[send_index] = name.charCodeAt(i);\n            //serial.writeNumber(name.charCodeAt(i));\n            send_index++;\n        }\n        let length = husky_lens_protocol_write_end();\n        //serial.writeNumber(length)\n        let Buffer = pins.createBufferFromArray(buffer);\n        protocolWrite(Buffer);\n        //}while(!wait(protocolCommand.COMMAND_RETURN_OK));\n    }\n    /**\n    * HuskyLens clear characters in the screen\n    */\n    //%block=\"Effacer tous les textes à l'écran\" group=\"Affichage sur l'écran\"\n    //% weight=26\n    export function clearOSD(): void {\n        writeAlgorithm(0x45, 0X35);\n        //while(!wait(protocolCommand.COMMAND_RETURN_OK));\n    }\n\n\n    function validateCheckSum() {\n\n        let stackSumIndex = receive_buffer[3] + CONTENT_INDEX;\n        let hk_sum = 0;\n        for (let i = 0; i < stackSumIndex; i++) {\n            hk_sum += receive_buffer[i];\n        }\n        hk_sum = hk_sum & 0xff;\n\n        return (hk_sum == receive_buffer[stackSumIndex]);\n    }\n\n    function husky_lens_protocol_write_end() {\n        if (send_fail) { return 0; }\n        if (send_index + 1 >= FRAME_BUFFER_SIZE) { return 0; }\n        send_buffer[CONTENT_SIZE_INDEX] = send_index - CONTENT_INDEX;\n        //serial.writeValue(\"618\", send_buffer[CONTENT_SIZE_INDEX])\n        let hk_sum = 0;\n        for (let i = 0; i < send_index; i++) {\n            hk_sum += send_buffer[i];\n        }\n\n        hk_sum = hk_sum & 0xff;\n        send_buffer[send_index] = hk_sum;\n        send_index++;\n        return send_index;\n    }\n\n    function husky_lens_protocol_write_begin(command = 0) {\n        send_fail = false;\n        send_buffer[HEADER_0_INDEX] = 0x55;\n        send_buffer[HEADER_1_INDEX] = 0xAA;\n        send_buffer[ADDRESS_INDEX] = 0x11;\n        //send_buffer[CONTENT_SIZE_INDEX] = datalen;\n        send_buffer[COMMAND_INDEX] = command;\n        send_index = CONTENT_INDEX;\n        return send_buffer;\n    }\n\n    function protocolWrite(buffer: Buffer) {\n        pins.i2cWriteBuffer(0x32, buffer, false);\n        basic.pause(50)\n    }\n\n    function processReturn() {\n        if (!wait(protocolCommand.COMMAND_RETURN_INFO)) return false;\n        protocolReadFiveInt16(protocolCommand.COMMAND_RETURN_INFO);\n        for (let i = 0; i < Protocol_t[1]; i++) {\n\n            if (!wait()) return false;\n            if (protocolReadFiveInt161(i, protocolCommand.COMMAND_RETURN_BLOCK)) continue;\n            else if (protocolReadFiveInt161(i, protocolCommand.COMMAND_RETURN_ARROW)) continue;\n            else return false;\n        }\n        return true;\n    }\n\n    function wait(command = 0) {\n        timerBegin();\n        while (!timerAvailable()) {\n            if (protocolAvailable()) {\n                if (command) {\n                    if (husky_lens_protocol_read_begin(command)) {\n                        //serial.writeNumber(0);\n                        return true;\n                    }\n                }\n                else {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    function husky_lens_protocol_read_begin(command = 0) {\n        if (command == receive_buffer[COMMAND_INDEX]) {\n            content_current = CONTENT_INDEX;\n            content_read_end = false;\n            receive_fail = false;\n            return true;\n        }\n        return false;\n    }\n\n    let timeOutDuration = 100;\n    let timeOutTimer: number\n    function timerBegin() {\n        timeOutTimer = input.runningTime();\n    }\n\n    function timerAvailable() {\n        return (input.runningTime() - timeOutTimer > timeOutDuration);\n    }\n\n    let m_i = 16\n    function protocolAvailable() {\n        let buf = pins.createBuffer(16)\n        if (m_i == 16) {\n            buf = pins.i2cReadBuffer(0x32, 16, false);\n            m_i = 0;\n        }\n        for (let i = m_i; i < 16; i++) {\n            if (husky_lens_protocol_receive(buf[i])) {\n                m_i++;\n                return true;\n            }\n            m_i++;\n        }\n        return false\n    }\n\n    function husky_lens_protocol_receive(data: number): boolean {\n        switch (receive_index) {\n            case HEADER_0_INDEX:\n                if (data != 0x55) { receive_index = 0; return false; }\n                receive_buffer[HEADER_0_INDEX] = 0x55;\n                break;\n            case HEADER_1_INDEX:\n                if (data != 0xAA) { receive_index = 0; return false; }\n                receive_buffer[HEADER_1_INDEX] = 0xAA;\n                break;\n            case ADDRESS_INDEX:\n                receive_buffer[ADDRESS_INDEX] = data;\n                break;\n            case CONTENT_SIZE_INDEX:\n                if (data >= FRAME_BUFFER_SIZE - PROTOCOL_SIZE) { receive_index = 0; return false; }\n                receive_buffer[CONTENT_SIZE_INDEX] = data;\n                break;\n            default:\n                receive_buffer[receive_index] = data;\n\n                if (receive_index == receive_buffer[CONTENT_SIZE_INDEX] + CONTENT_INDEX) {\n                    content_end = receive_index;\n                    receive_index = 0;\n                    return validateCheckSum();\n\n                }\n                break;\n        }\n        receive_index++;\n        return false;\n    }\n\n    function husky_lens_protocol_write_int16(content = 0) {\n\n        let x: number = ((content.toString()).length)\n        if (send_index + x >= FRAME_BUFFER_SIZE) { send_fail = true; return; }\n        send_buffer[send_index] = content & 0xff;\n        send_buffer[send_index + 1] = (content >> 8) & 0xff;\n        send_index += 2;\n    }\n\n    function protocolReadFiveInt16(command = 0) {\n        if (husky_lens_protocol_read_begin(command)) {\n            Protocol_t[0] = command;\n            Protocol_t[1] = husky_lens_protocol_read_int16();\n            Protocol_t[2] = husky_lens_protocol_read_int16();\n            Protocol_t[3] = husky_lens_protocol_read_int16();\n            Protocol_t[4] = husky_lens_protocol_read_int16();\n            Protocol_t[5] = husky_lens_protocol_read_int16();\n            husky_lens_protocol_read_end();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    function protocolReadFiveInt161(i: number, command = 0) {\n        if (husky_lens_protocol_read_begin(command)) {\n            protocolPtr[i][0] = command;\n            protocolPtr[i][1] = husky_lens_protocol_read_int16();\n            protocolPtr[i][2] = husky_lens_protocol_read_int16();\n            protocolPtr[i][3] = husky_lens_protocol_read_int16();\n            protocolPtr[i][4] = husky_lens_protocol_read_int16();\n            protocolPtr[i][5] = husky_lens_protocol_read_int16();\n            husky_lens_protocol_read_end();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    function husky_lens_protocol_read_int16() {\n        if (content_current >= content_end || content_read_end) { receive_fail = true; return 0; }\n        let result = receive_buffer[content_current + 1] << 8 | receive_buffer[content_current];\n        content_current += 2\n        return result;\n    }\n\n    function husky_lens_protocol_read_end() {\n        if (receive_fail) {\n            receive_fail = false;\n            return false;\n        }\n        return content_current == content_end;\n    }\n\n    function countLearnedIDs() {\n        return Protocol_t[2]\n    }\n\n    function countBlocks(ID: number) {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_BLOCK && protocolPtr[i][5] == ID) counter++;\n        }\n        return counter;\n    }\n\n    function countBlocks_s() {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_BLOCK) counter++;\n        }\n        //serial.writeNumber(counter)\n        return counter;\n    }\n\n    function countArrows(ID: number) {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_ARROW && protocolPtr[i][5] == ID) counter++;\n        }\n        return counter;\n    }\n\n    function countArrows_s() {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_ARROW) counter++;\n        }\n        return counter;\n    }\n\n    function readKnock() {\n        for (let i = 0; i < 5; i++) {\n            protocolWriteCommand(protocolCommand.COMMAND_REQUEST_KNOCK);//I2C\n            if (wait(protocolCommand.COMMAND_RETURN_OK)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function writeForget() {\n        for (let i = 0; i < 5; i++) {\n            protocolWriteCommand(protocolCommand.COMMAND_REQUEST_FORGET);\n            if (wait(protocolCommand.COMMAND_RETURN_OK)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function protocolWriteCommand(command = 0) {\n        Protocol_t[0] = command;\n        let buffer = husky_lens_protocol_write_begin(Protocol_t[0]);\n        let length = husky_lens_protocol_write_end();\n        let Buffer = pins.createBufferFromArray(buffer);\n        protocolWrite(Buffer);\n    }\n\n    function protocolReadCommand(command = 0) {\n        if (husky_lens_protocol_read_begin(command)) {\n            Protocol_t[0] = command;\n            husky_lens_protocol_read_end();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    function writeAlgorithm(algorithmType: number, comemand = 0) {\n        protocolWriteOneInt16(algorithmType, comemand);\n        //return true//wait(protocolCommand.COMMAND_RETURN_OK);\n        //while(!wait(protocolCommand.COMMAND_RETURN_OK));\n        //return true\n    }\n\n    function writeLearn(algorithmType: number) {\n        protocolWriteOneInt16(algorithmType, protocolCommand.COMMAND_REQUEST_LEARN);\n        return wait(protocolCommand.COMMAND_RETURN_OK);\n    }\n\n    function protocolWriteOneInt16(algorithmType: number, command = 0) {\n        let buffer = husky_lens_protocol_write_begin(command);\n        husky_lens_protocol_write_int16(algorithmType);\n        let length = husky_lens_protocol_write_end();\n        let Buffer = pins.createBufferFromArray(buffer);\n        protocolWrite(Buffer);\n    }\n\n    function cycle_block(ID: number, index = 1): number {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_BLOCK && protocolPtr[i][5] == ID) {\n                counter++;\n                if (index == counter) return i;\n\n            }\n        }\n        return null;\n    }\n\n    function cycle_arrow(ID: number, index = 1): number {\n        let counter = 0;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_ARROW && protocolPtr[i][5] == ID) {\n                counter++;\n                if (index == counter) return i;\n\n            }\n        }\n        return null;\n    }\n\n    function readBlockCenterParameterDirect(): number {\n        let distanceMinIndex = -1;\n        let distanceMin = 65535;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_BLOCK) {\n                let distance = Math.round(Math.sqrt(Math.abs(protocolPtr[i][1] - 320 / 2))) + Math.round(Math.sqrt(Math.abs(protocolPtr[i][2] - 240 / 2)));\n                if (distance < distanceMin) {\n                    distanceMin = distance;\n                    distanceMinIndex = i;\n                }\n            }\n        }\n        return distanceMinIndex\n    }\n\n    function readArrowCenterParameterDirect(): number {\n        let distanceMinIndex = -1;\n        let distanceMin = 65535;\n        for (let i = 0; i < Protocol_t[1]; i++) {\n            if (protocolPtr[i][0] == protocolCommand.COMMAND_RETURN_ARROW) {\n                let distance = Math.round(Math.sqrt(Math.abs(protocolPtr[i][1] - 320 / 2))) + Math.round(Math.sqrt(Math.abs(protocolPtr[i][2] - 240 / 2)));\n                if (distance < distanceMin) {\n                    distanceMin = distance;\n                    distanceMinIndex = i;\n                }\n            }\n        }\n        return distanceMinIndex\n    }\n\n    function no(): void {\n        basic.showIcon(IconNames.No);\n        basic.pause(100);\n        basic.clearScreen();\n        basic.pause(100);\n    }\n    function yes(): void {\n        basic.showIcon(IconNames.Yes);\n        basic.pause(100);\n        basic.clearScreen();\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Robot et IA\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"ws2812b\": \"github:microsoft/pxt-ws2812b#v0.1.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.61\",\n        \"tag\": \"v7.0.61\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/1bb8145a013b8c3718bf6c82138e87e3ecb5514d\",\n        \"target\": \"7.0.61\",\n        \"pxt\": \"11.1.14\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[{"id":"32095-92313-78013-00014","timestamp":1751617789857}],"lastSaveTime":1751617924897}